## v8 内存分配

v8 中, 主要将内存分为新生代和老生代

新生代的对象为存活时间较短的对象, 老生代为常驻或者存活时间较长的对象

| 新生代             | 老生代                     |
| ------------------ | -------------------------- |
| 最大值为32mb和16mb | 默认最大1464mb, 减去新生代 |



## Scavenge 算法

新生代的对象通过 Scavenge 算法进行垃圾回收, 这个算法具体采用了 Cheney 算法

cheney 算法简单讲解

> 将内存一分为2, 一个叫做 from, 一个叫做 to, 我们声明的对象放在 from 里面, 进行垃圾回收时, 检查 from 里面存活的对象, **复制**到 to, 复制完成后 from 清空, from 和 to 标记互换

缺点就是只能用堆内存的一半, 典型的牺牲空间换取时间的算法

在新生代中 cheney 算法多次运行后发现多次复制的对象, 这时会被标记为 常驻对象, 会 **晋升** 到老生代内存区域

晋升也有两个判断, 如果对象经历过清除, 则复制到老生代, 否则复制到 to

如果 to 空间占比超过 25%, 那这个对象直接复制到 老生代



## 老生代的 GC

老生代采取 **标记清除** 方式来回收

因为新生代用来保存存活时间短的对象, 就是说每一次垃圾回收存活的对象少, 采取复制清空比较高效

但是老生代则是存储常驻对象, 死亡对象比较少, 标记清除则比较高效

标记清除可能导致内存空隙, v8 还会采取另一种方式移位, 达到减少空隙的效果









