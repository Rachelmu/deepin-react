## 五大设计原则

- Single `单一职责`
  - 一个程序只做一件事
  - 如果功能复杂就分开
- Open `开放封闭`
  - 对扩展开放, 对修改封闭
  - 扩展需求时, 鼓励增加代码, 而非修改源代码
  - 软件设计终极目标
- L `李氏置换`
  - 子类覆盖父类
  - 父类能出现的地方子类就能出现
  - JS不常用
- Interface `接口独立原则`
  - 保持接口独立, 避免出现胖接口
  - JS 使用较少
  - 类似单一职责, 这里只强调接口
- Depend `依赖导致`
  - 面向接口编程, 只关注接口功能, 而不关注类的实现

## 1. 工厂模式

> 简单来说就是将 new 单独封装

```js
class People {
    constructor (name, age) {
        this.name = name
        this.age = age
    }
}

const createPeople = (name, age) => new People(name, age)
```

## 2. 单例模式

> 系统中唯一调用
>
> 一个类只有一个实例
>
> 只能内部使用

但是 js 的缺陷导致不能完整的支持单例模式, 只能共同遵守约定

```js
class SingleObject {
    constructor (...rest) {
   		// ...
    }
}

// 使用闭包实现
SingleObject.getInstance = () => {
    let instance
    return () => {
        if (!instance) {
            return new SingleObject('...')
        }
        return instance
    }
}
```

## 3. 装饰器模式

> 广义上就是不修改内部代码但是实现新增功能的效果
>
> 非侵入式

```js
class Circle {
    draw () {
        console.log('我画了一个圆形')
    }
}
class Decorator {
    constructor (target) {
        this.target = target;
    }
    draw () {
        this.circle.draw();
        this.setDecorator(this.target)
    }
    setDecorator (target) {
        console.log('设置红色边框')
    }
}
let obj = new Decorator(new Circle())
obj.draw()
```

## 4. 代理模式

> 使用者无权直接访问对象, 通过 中间代理实现访问
>
> 代理对访问进行控制和授权

比如 ...es6 的 proxy

## 5. 观察者模式

> 发布 -> 订阅
>
> 一对 n