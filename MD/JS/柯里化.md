## 柯里化

> 柯里化是将多个参数的函数换成可以一个一个参数传入的技术

## 用途

比如一个获取数据的函数

```js
// 大致写一下
function ajax(type, methods, url, data, ...rest) {
  // 获取数据操作...
}
// 如果要使用
ajax('type', 'methods', 'url', 'data',...)
ajax('type', 'methods', 'url', 'data',...)
ajax('type', 'methods', 'url', 'data',...)
// 这样可以看出来参数冗余非常严重
```

假如我们拥有一个柯里化函数...

我们就可以骚起来了

```js
let ajaxCurry = curry(ajax)

// 以 POST 类型请求数据
let post = ajaxCurry('POST')
post('www.test.com', "name=kevin")

// 以 POST 类型请求来自于 www.test.com 的数据
let postFromTest = post('www.test.com')
postFromTest("name=kevin")
```

柯里化函数可以很好地解决**需要多次调用, 并且每一次调用参数仅仅修改小部分的函数**

### 第一个版本

```js
const curry = (fn, ...wrapperArgs) => {
  return (...innerArgs) => {
    let newArgs = [...wrapperArgs, ...innerArgs]
    return fn.apply(this, newArgs)
  }
}

// 可以这么用
function add(a, b) {
    return a + b;
}

let addCurry = curry(add, 1, 2);
addCurry() // 3
//或者
let addCurry = curry(add, 1);
addCurry(2) // 3
//或者
let addCurry = curry(add);
addCurry(1, 2) // 3
```

是有点柯里化感觉了, 但不是我们想要的, 我们可以用这个来写更完美的柯里化函数

### 第二个版本

```js
const subCurry = (fn, ...wrapperArgs) => {
  return (...innerArgs) => {
    let newArgs = [...wrapperArgs, ...innerArgs]
    return fn.apply(this, newArgs)
  }
}

const curry = (fn, length) => {
  length = length || fn.length
  return (...rest) => {
    let nowArgLength = rest.length
    if (nowArgLength < length) {
      let combinedArgs = [fn, ...rest]
      return curry(subCurry.apply(this, combinedArgs), length - nowArgLength)
    } else {
      return fn.apply(this, rest)
    }
  }
}
```



 