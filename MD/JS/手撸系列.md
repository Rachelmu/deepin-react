## Promise

简单版

```js
class MyPromise {
  PENDING = 'pending'
  RESOLVED = 'resolved'
  REJECTED = 'rejected'
  constructor (fn) {
    this.state = this.PENDING
    this.value = null
    this.resolvedCallbacks = []
    this.rejectedCallbacks = []
    
    const resolve = v => {
      if (this.state === this.PENDING) {
        this.state = this.RESOLVED
        this.value = v
        this.resolvedCallbacks.map(fn => fn(this.value))
      }
    }
    
    const rejecte = e => {
      if (this.state === this.PENDING) {
        this.state = this.REJECTED
        this.value = e
        this.rejectedCallbacks.map(fn => fn(this.value))
      }
    }
    
    try {
      fn(resolve, rejecte)
    } catch (e) {
      rejected(e)
    }
  }

	then = (fullfilled, rejected) => {
    fullfilled = typeof fullfilled === 'function' ? fullfilled : v => v
    rejected = typeof rejected === 'function' ? rejected : e => { throw e }
    
    if (this.state === this.PENDING) {
      this.resolvedCallbacks.push(fullfilled)
      this.rejectedCallbacks.push(rejected)
    }
    
    if (this.state === this.RESOLVED) {
      fullfilled(this.value)
    }
    
    if (this.state === this.REJECTED) {
      rejected(this.value)
    }
  }
}
```

### Promise.all

```js
Promise.myAll = function (proArr) {
  let result = []
  
  for (let i = 0, len = proArr.length; i < len; i ++) {
    proArr[i].then(v => {
      result.push(v)
    }, e => {
      return Promise.reject(e)
    })
  }
  return Promise.resolve(result)
}
```

### Promise.race



## 自带函数系列

*Array.prototype.reduce*     `数组累加器,接受两个参数,第一个是处理函数(两个参数,第一个是累加值,默认是数组第一位,第二个是下一个值),第二个是初始值(当需要累加对象的属性时,初始值是必须的)`

```js
Array.prototype.myReduce = function (fn, index) {
  let arr = this, index = index || arr[0]
  for (let i = 0, len = arr.length - 1; i < len; i ++) {
    index = fn(index, arr[i + 1], i, arr)
  }
  return index
}
```

*Array.prototype.map*    `map 函数,对每一项都执行一次函数,并且把新结果以数组的形式返回`

```js
Array.prototype.myMap = function (fn) {
  let arr = this, result = []
  for (let i = 0, len = arr.length; i < len; i ++) {
    result.push(fn(arr[i]))
  }
  return result
}
```



## instanceOf

```js
const myInatanceOf = (R, L) => {
    var O = R.prototype; // 取 R 的显示原型
    L = L.__proto__; // 取 L 的隐式原型
    while (true) {
        if (L === null) return false;
        if (O === L)
            // 这里重点:当 O 严格等于 L 时,返回 true
            return true;
        L = L.__proto__;
    }
}
}
```