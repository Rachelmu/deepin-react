## 手撸系列

### Promise

简单版

```js
class MyPromise {
  PENDING = 'pending'
	RESOLVED = 'resolved'
	REJECTED = 'rejected'
  constructor (fn) {
    this.state = this.PENDING
    this.value = null
    this.resolvedCallbacks = []
    this.rejectedCallbacks = []
    
    const resolve = v => {
      if (this.state === this.PENDING) {
        this.state = this.RESOLVED
        this.value = v
        this.resolvedCallbacks.map(fn => fn(this.value))
      }
    }
    
    const rejecte = e => {
      if (this.state === this.PENDING) {
        this.state = this.REJECTED
        this.value = e
        this.rejectedCallbacks.map(fn => fn(this.value))
      }
    }
    
    try {
      fn(resolve, rejecte)
    } catch (e) {
      rejected(e)
    }
  }

	then = (fullfilled, rejected) => {
    fullfilled = typeof fullfilled === 'function' ? fullfilled : v => v
    rejected = typeof rejected === 'function' ? rejected : e => { throw e }
    
    if (this.state === this.PENDING) {
      this.resolvedCallbacks.push(fullfilled)
      this.rejectedCallbacks.push(rejected)
    }
    
    if (this.state === this.RESOLVED) {
      fullfilled(this.value)
    }
    
    if (this.state === this.REJECTED) {
      rejected(this.value)
    }
  }
}
```

### Promise.all

```js
Promise.myAll = function (proArr) {
  let result = []
  
  for (let i = 0, len = proArr.length; i < len; i ++) {
    proArr[i].then(v => {
      result.push(v)
    }, e => {
      return Promise.reject(e)
    })
  }
  return Promise.resolve(result)
}
```

### Promise.race

```js

```



### 自带函数系列

Array.prototype.reduce `数组累加器,接受两个参数,第一个是处理函数(两个参数,第一个是累加值,默认是数组第一位,第二个是下一个值),第二个是初始值(当需要累加对象的属性时,初始值是必须的)`

```js
Array.prototype.myReduce = function (fn, index) {
  let arr = this, index = index || arr[0]
  for (let i = 0, len = arr.length - 1; i < len; i ++) {
    index = fn(index, arr[i + 1], i , arr)
  }
  return index
}
```



