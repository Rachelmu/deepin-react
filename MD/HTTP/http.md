## HTTP 协议

### 请求方法

GET`通过uri获取资源`, POST`用于添加新的内容`, PUT`用于修改某个内容`,DELETE`删除某个内容`, 

CONNECT`用于代理进行传输,例如使用ssl`, OPTIONS`询问可以执行哪些方法`, PATCH`部分文档修改`, PROFIND`查看属性`, 

COPY`拷贝`, MOVE`移动`, LOCK`加锁`, UNLOCK`解锁`, TRACE`远程诊断服务器`, 

HEAD`类似get但不返回数据,用于检索数据, 返回数据元信息`

### URL和URI的区别

URI 是统一资源标识符, URL 是统一资源定位符, URN 是统一资源名称

URI = URL + URN  (范围)

### 客户端请求格式

三部分

> 请求方法   URI   版本
>
> 请求头
>
> 请求正文(数据, 一般POST数据在这里, GET请求这里是空的)

### 通用头字段(请求和响应均可)

| 字段          | 意思                                                         |
| ------------- | ------------------------------------------------------------ |
| Cache-Control | no-cache:客户端或者此数据不允许缓存<br />no-store:缓存应该尽快从存储器删除文档所有痕迹<br />max-age:缓存持续时间<br />min-fresh:至少在未来n秒内缓存保持新鲜 |
| Connection    | close: 完成此次传输后断开连接<br />keepalive: 表示完成后不要断开,等待后续请求<br />Keep-Alive: 表示持续连接时间 |
| Date          | 消息发送的时间                                               |



### 请求头字段表格

| 字段              | 意思                                                         |
| ----------------- | ------------------------------------------------------------ |
| Accept            | 表示客户端可以接收的资源类型, text/image/html等几种常用类型  |
| Accept-Charset    | 指定浏览器可以显示的字符集                                   |
| Accept-Encoding   | 浏览器支持的编码类型, gzip或compress是常见的                 |
| Accept-Language   | 客户端首选语言                                               |
| Authorization     | 客户端在访问受密码保护的网页时验证自己的身份                 |
| Connection        | 表示客户端是否可以持久连接, 设置为keep-alive                 |
| Content-Length    | 只用于POST请求, 并提供POST数据大小                           |
| Cookie            | 请求时带上客户端Cookie, 就是在这里                           |
| Host              | 指定信息的URL和端口                                          |
| If-Modified-Since | 在客户端保存的信息超过了服务器预设的过期时间, 设置这个属性, 如果服务端资源未更新, 则返回304, 当客户端访问页面时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发往客户端，客户端记录修改时间，再次请求本地存在的cache页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的最后修改时间戳发送回去，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担 |
| User-Agent        | 识别浏览器客户端以及其他客户端                               |

### 响应头字段表格

| 字段           | 意思                                                         |
| :------------- | ------------------------------------------------------------ |
| Age            | 当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了 |
| Server         | 服务端是什么服务器软件, 及版本信息                           |
| Accepts-Ranges | WEB服务器表明自己是否接受获取其某个实体的一部分(比如文件的一部分)的请求<br />bytes：表示接受，none：表示不接受 |
| Vary           | WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求 |



## HTTP 2.0 协议

### 二进制传输

> 在之前的 Http 协议中, 数据通过文本的形式传输, 在 2.0 中采取新的编码格式, 所有数据都会被切割, 并采取二进制代码

### 多路复用

> 在 2.0 中有两个非常重要的概念, **帧和流**, 每一帧会标记属于哪个流, 在一个 TCP 链接中可以存在多个流, 也就是发送多个请求, 避免旧版本的队头阻塞问题, 极大的提升性能

### Header 压缩

> 在老版本里面, 因为 cookie, 每一次传输都会携带很重的头, 在 2.0 进行头部压缩, 使用 hpack 格式
>
> 在两端维护了索引表, 用于存储已存在的 header 键名, 后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

### Server Push

> 在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。
>
> 可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。



## QUIC 协议 ( from Google )

> 主要是 TCP 的问题, 多路复用可能导致一个域名下只存在一个连接, 但是万一出现丢包现象, 所有的请求都会等待这个包的重新传输, 这就尴尬了...
>
> 谷歌基于 UDP 研究出 QUIC





