## 目录

1. [排序](./sort.md)
2. [数据结构](./数据结构.md)





## 其他知识

每一次子规模都需要一样

就可以使用递归复杂度通式: T(n) = a * T(n/b) + O(n^c)

| T(n)     | a * T(n / b)                          | O(n ^ c)           |
| -------- | ------------------------------------- | ------------------ |
| 总样本量 | 递归需要处理的样本量, a代表发生多少次 | 除去递归其他样本量 |

- log(b, a) > d 复杂度为 O(n ^ log(b, a))
- log(b, a) = d 复杂度为 O(n ^ d * logN)
- log(b, a) < d 复杂度为 O(n ^ d)

所有的递归都是可以拆为非递归



两个队列实现栈

- 设置两个队列, 一个 data, 一个 help
- 数据进入队列, 进入 data
- 返回数据, 依次返回前面的数, 进入 help 队列
- 最后一个数返回
- 两个引用互换

两个栈实现队列

- 两个栈, push 和 pop
- 用户给的数放在 push
- 然后依次从 push 压入 pop
  - 必须一次压完
  - 保证 pop 没有数据
- 用户从 pop 取数据, 顺序正常

### 布隆过滤器

- 会误报
- 一个 URL 不在数组里面, 也可能返回 true
- 但是通过调整数组的大小, 和 hash 函数的个数, 可以得到不同的失误率
- 数组越大, 失误率越低
- 其他的不会

一个 URL 经过 k 个 hash 函数描黑

查: 一个 URL 经过 k 个 hash 函数, 算出 k 个位置, 如果都为黑色, 则在黑名单里面

如果有一个不为黑, 则不为黑

布隆过滤器公式 m = - (n * lnP) / (ln2)^2

### 一致性哈希

### 并查集

> 检查两个元素是否属于一个集合
>
> 两个元素各自所在的集合合并在一起



搜索二叉树左子树都是比右子树小的

平衡二叉树: 左子树右子树高度差不超过1