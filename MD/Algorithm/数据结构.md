## 队列

> 连续的一段存储空间

## 链表



## 树

### 二叉树

> 每一个节点只有两片叶子

#### 完美二叉树

> 类似三角形..., 全部填满

#### 完全二叉树

>倒数第二排向上为完美二叉树, 最后一排可以不排满, 但必须顺序排列, 不能空位

完全二叉树就是使用数组来模拟的一个结构

[0, 1, 2, 3]

> 左儿子: 2i + 1
>
> 右儿子: 2i + 2
>
> 父节点: (i - 1) / 2

二叉树的实现

```js
class Node {
    constructor (data) {
        this.value = data
    }
    left (val) {
        this.left = new Node(val)
    }
    right (val) {
        this.right = new Node(val)
    }
}
```

```
	  1
	/	\
   2     3
  / \   / \
 4   5 6   7

这棵树的打印顺序为 1, 2, 4, 4, 4, 2, 5, 5, 5, 2, 1, 3, 6, 6, 6, 3, 7, 7, 7, 3, 1
每一个数都会遍历三次, 看数是第几次出现
打印第一次出现, 先序遍历 1, 2, 4, 5, 3, 6, 7
打印第二次出现, 中序遍历 4, 2, 5, 1, 6, 3, 7
打印第三次出现, 后序遍历 4, 5, 2, 6, 7, 3, 1
```







先序遍历: 先打印顶点, 然后打印整个左子树, 然后打印整个右子树的过程

```js
function preOrderRacer(head) {
    if (!head) {
        return
    }
    console.log(head.value)
    preOrderRacer(head.left)
    preOrderRacer(head.right)
}
```

中序遍历: 先打印左子树, 然后打印顶点, 然后打印右子树

```js
function preOrderRacer(head) {
    if (!head) {
        return
    }
    preOrderRacer(head.left)
    console.log(head.value)
    preOrderRacer(head.right)
}
```

后序遍历: 先打印左子树, 然后打印右子树, 最后打印顶点

```js
function preOrderRacer(head) {
    if (!head) {
        return
    }
    preOrderRacer(head.left)
    preOrderRacer(head.right)
    console.log(head.value)
}
```



## 哈系表





## 堆

> 完全二叉树

大根堆, 小根堆

进来一个数, 仅需要 logn 的代价插入

heapinsert 和 heapfiy

建立堆的过程复杂度为 O(n), 优先级队列结构就是堆结构

堆排序