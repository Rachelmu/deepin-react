## 递归版本

```js
// 先序便利
const getItemFromTree = head => {
    if (!head) return
    
    console.log(head.value)
    getItemFromTree(head.left)
    getItemFromTree(head.right)
}

// 中序遍历
const getItemFromTree = head => {
    if (!head) return
    
    getItemFromTree(head.left)
    console.log(head.value)
    getItemFromTree(head.right)
}

// 后序遍历
const getItemFromTree = head => {
    if (!head) return
    
    getItemFromTree(head.left)
    getItemFromTree(head.right)
    console.log(head.value)
}
```

## 非递归版本

### 先序遍历

```js
const preOrderRacer = head => {
    if (!head) return
    let arr = []
    arr.push(head)
    while (arr.length !== 0) {
        head = arr.pop()
        console.log(head.value)
        head.right && arr.push(head.right)
        head.left && arr.push(head.left)
    } 
}
// 当从 arr 里面取出一个 head 的时候, 先 push 右, 后 push 左, 而使用了栈的特性, 打印会先打印左, 后打印右
// 当 arr 为空时, 说明打印完毕
```



### 中序遍历

```js
const inOrderRacer = head => {
    if (!head) return
    let arr = []
    while (arr.length !== 0 || head) {
        if (head) {
            arr.push(head)
            head = head.left
        } else {
            head = arr.pop()
            console.log(head.value)
            head = head.right
        }
    }
}
// 当前节点为空, 从 arr 里面取出一个, 指针往右
// 当前节点不为空, 当前节点压入 arr, 指针往左
```



### 后序遍历

```js
const posOrderRacer = head => {
	if (!head) return
    let arr1 = [], arr2 = []
    arr1.push(head)
    while (arr1.length !== 0) {
        head = arr1.pop()
        arr2.push(head)
        head.left && arr1.push(head.left)
        head.right && arr1.push(head.right)
    }
    while (arr2.length !== 0) {
        console.log(arr2.pop().value)
    }
}
// 妙啊, 根据前序遍历(head, left, right), 压入变为 head, right, left, 并且存储在另一个栈中, 最后循环另一个栈打印即可
```

